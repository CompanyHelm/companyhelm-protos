syntax = "proto3";
package companyhelm.runner.v1;

import "buf/validate/validate.proto";


// Transport contract between backend control plane and runner clients.
// RegisterRunner performs a capability handshake; CommandChannel carries
// asynchronous requests and updates correlated by request_id.
service AgentRunnerControlService {
  // Called once when a runner connects so the server can decide whether this
  // runner instance is allowed to participate in request processing.
  rpc RegisterRunner(RegisterRunnerRequest) returns (RegisterRunnerResponse);
  // Bidirectional stream used for the lifecycle of a connected runner.
  // Server pushes work; runner pushes updates/results.
  // Client initiated requests should have their own rpc call.
  rpc ControlChannel(stream ClientMessage) returns (stream ServerMessage);
  // list of GitHub App installations already associated with it.
  rpc ListGithubInstallations(ListGithubInstallationsRequest) returns (ListGithubInstallationsResponse);
  // Mints a short-lived token for one installation so the runner can call
  // GitHub APIs without storing long-lived credentials.
  rpc GithubInstallationAccessToken(GithubInstallationAccessTokenRequest) returns (GithubInstallationAccessTokenResponse);
}

/************************************************/
/* REGISTRATION PROTOCOL                        */ 
/************************************************/

// runner identity is currently inferred from transport-level
message RegisterRunnerRequest {
  // agent sdks supported by the runner
  repeated AgentSdk agent_sdks = 1;
}

message AgentSdk {
  // name of the sdk, e.g. Codex, Claude Code, etc
  string name = 1 [(buf.validate.field).string.min_len = 1];
  // models supported by the sdk
  repeated LLMModel models = 2;
}

message LLMModel {
  // name of the model, e.g. gpt-5.3-codex, 
  string name = 1 [(buf.validate.field).string.min_len = 1];
  // reasoning levels this model supports (empty means default only).
  repeated string reasoning = 2;
}

message ModelReasoning {
  // name of the reasoning level, e.g. xhign, high, medium, low
  string name = 1 [(buf.validate.field).string.min_len = 1];
}

message RegisterRunnerResponse {
}

/************************************************/
/* CONTROL CHANNEL PROTOCOL                     */ 
/************************************************/

// This is a response to a server request.
message ClientMessage {
  // not included for client generated updates
  optional string request_id = 1;
  oneof payload {
    RequestError request_error = 2;
    AgentUpdate agent_update = 3;
    ThreadUpdate thread_update = 4;
    TurnUpdate turn_update = 5;
    ItemUpdate item_update = 6;
    SkillMpUpdate skill_mp_update = 7;
    ThreadNameUpdate thread_name_update = 8;
  }
}

message RequestError {
  string error_message = 1 [(buf.validate.field).string.min_len = 1];
}

enum AgentStatus {
  AGENT_STATUS_UNKNOWN = 0;
  AGENT_STATUS_READY = 1;
  AGENT_STATUS_DELETED = 2;
}

message AgentUpdate {
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  AgentStatus status = 2; 
}

enum ThreadStatus {
  THREAD_STATUS_UNKNOWN = 0;
  THREAD_STATUS_READY = 1;
  THREAD_STATUS_DELETED = 2;
}

message ThreadUpdate {
  string thread_id = 1 [(buf.validate.field).string.min_len = 1];
  ThreadStatus status = 2;
}

message ThreadNameUpdate {
  string thread_id = 1 [(buf.validate.field).string.min_len = 1];
  optional string thread_name = 2; // define: absent => clear/unset
}

enum TurnStatus {
  TURN_STATUS_UNKNOWN = 0;
  TURN_STATUS_RUNNING = 1;
  TURN_STATUS_COMPLETED = 2;
}

message TurnUpdate {
  string sdk_turn_id = 1 [(buf.validate.field).string.min_len = 1];
  TurnStatus status = 2;
  string thread_id = 3 [(buf.validate.field).string.min_len = 1];
}

enum ItemStatus {
  ITEM_STATUS_UNKNOWN = 0;
  ITEM_STATUS_RUNNING = 1;
  ITEM_STATUS_COMPLETED = 2;
}

message ItemUpdate {
  string sdk_item_id = 1 [(buf.validate.field).string.min_len = 1];
  ItemStatus status = 2;
  // Item type that was started
  ItemType item_type = 5;
  // text of the itme
  optional string text = 6;
  // Command execution item, if type is COMMAND_EXECUTION
  optional CommandExecutionItem command_execution_item = 7;
  string thread_id = 8 [(buf.validate.field).string.min_len = 1];
  string sdk_turn_id = 9 [(buf.validate.field).string.min_len = 1];
}

message CommandExecutionItem {
  string command = 1 [(buf.validate.field).string.min_len = 1];
  string cwd = 2 [(buf.validate.field).string.min_len = 1];
  string process_id = 3 [(buf.validate.field).string.min_len = 1];
  optional string output = 4;
}

enum ItemType {
  ITEM_TYPE_UNKNOWN = 0;
  USER_MESSAGE = 1;
  AGENT_MESSAGE = 2;
  REASONING = 4;
  COMMAND_EXECUTION = 5;
}

enum SkillMpStatus {
  SKILL_MP_STATUS_UNKNOWN = 0;
  SKILL_MP_STATUS_INSTALLED = 1;
  SKILL_MP_STATUS_DELETED = 2;
}

message SkillMpUpdate {
  // Agent receiving the installation result.
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  SkillMpStatus status = 2;
  // Skill identifier this update belongs to.
  string package_name = 3 [(buf.validate.field).string.min_len = 1];
}

// Messages sent from server to runner over ControlChannel.
message ServerMessage {
  oneof request {
    CreateAgentRequest create_agent_request = 2;
    DeleteAgentRequest delete_agent_request = 3;
    CreateThreadRequest create_thread_request = 4;
    DeleteThreadRequest delete_thread_request = 5;
    CreateUserMessageRequest create_user_message_request = 6;
    InstallSkillsMpRequest install_skills_mp_request = 7;
    InterruptTurnRequest interrupt_turn_request = 8;
  }
}

message CreateAgentRequest {
  // Agent identifier to create
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  // SDK executor to use (for example codex/openai), chosen by control plane.
  string agent_sdk = 2 [(buf.validate.field).string.min_len = 1];
}

message DeleteAgentRequest {
  // Agent identifier to delete
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
}

message CreateThreadRequest {
  // Agent identifier to create the thread for
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  // LLM model to use for the thread
  string model = 2 [(buf.validate.field).string.min_len = 1];
  // Optional, reasoning level to use for the thread
  optional string reasoning_level = 3;
  // Thread identifier to create
  string thread_id = 4 [(buf.validate.field).string.min_len = 1];
  // Optional, additional model instructions to use for the thread
  optional string additional_model_instructions = 5;
}

message DeleteThreadRequest {
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  // Thread identifier to delete
  string thread_id = 2 [(buf.validate.field).string.min_len = 1];
}

message CreateUserMessageRequest {
  // Agent identifier that the turn was created for
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  // Thread identifier
  string thread_id = 2 [(buf.validate.field).string.min_len = 1];
  // Text to send to the turn
  string text = 3 [(buf.validate.field).string.min_len = 1];
  // Whether to allow the current running turn to be steered
  // If there are is a running turn and allows_steer is false the request will be rejected.
  bool allow_steer = 6;
  // Model identifier passed to the selected SDK for message execution.
  optional string model = 4;
  // Reasoning profile consumed by SDK-specific adapters when supported.
  optional string model_reasoning_level = 5;
}


message InstallSkillsMpRequest {
  // Agent receiving the new skill package.
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  // Package coordinate the runner installer resolves/downloads.
  string package_name = 2 [(buf.validate.field).string.min_len = 1];
}

message InterruptTurnRequest {
  // Agent identifier that the turn was created for
  string agent_id = 1 [(buf.validate.field).string.min_len = 1];
  // Thread identifier
  string thread_id = 2 [(buf.validate.field).string.min_len = 1];
}

/************************************************/
/* GITHUB INSTALLATION PROTOCOL                 */ 
/************************************************/

message GithubInstallation {
  // GitHub App installation identifier stored on backend.
  int64 installation_id = 1 [(buf.validate.field).int64.gte = 1];
}

// Empty because runner scope is inferred from authenticated caller.
message ListGithubInstallationsRequest {
}

message ListGithubInstallationsResponse {
  // Installations currently linked to this runner/account context.
  repeated GithubInstallation installations = 1;
}

message GithubInstallationAccessTokenRequest {
  // Installation for which the runner is requesting a fresh token.
  int64 installation_id = 1 [(buf.validate.field).int64.gte = 1];
}

message GithubInstallationAccessTokenResponse {
  // Echo of requested installation for client-side correlation.
  int64 installation_id = 1 [(buf.validate.field).int64.gte = 1];
  // Short-lived GitHub access token; treat as secret and do not persist.
  string access_token = 2 [(buf.validate.field).string.min_len = 1];
  // Expiry timestamp so callers can refresh proactively before 401s.
  int64 access_token_expires_unix_time_ms = 3;
  // Repository names/paths this token is authorized to access.
  repeated string repositories = 4 [(buf.validate.field).repeated.items.string.min_len = 1];
}
